⚫●◽★
https://www.bilibili.com/video/BV1PY411e7J6
——————————————————————
第 01 章：Java 语言概述
第 02 章：变量与运算符
第 03 章：流程控制语句
第 04 章：IDEA 的安装与使用
第 05 章：数组
第 06 章：面向对象编程(基础)
第 07 章：面向对象编程(进阶)
第 08 章：面向对象编程(高级)
第 09 章：异常处理
第 10 章：多线程
第 11 章：常用类与基础 API
第 12 章：集合框架
第 13 章：泛型
第 14 章：数据结构与集合源码
第 15 章：File 类与 IO 流
第 16 章：网络编程
第 17 章：反射机制
第 18 章：JDK8-17 新特性
————————————————————————
⚫第06章_面向对象编程（基础）
●6创建对象
类名 对象名 = new 类名();
●13匿名对象
不定义对象的句柄，而直接调用这个对象的方法
new Person().shout();
●17成员变量
静态static类变量，非静态实例变量
●21方法
[修饰符]： public、protected、private、static、abstract、native、final、synchronized
返回值类型：如果返回值类型不是void则return必要
方法名
([形参列表])
[throws 异常列表]
●32重载方法
方法重名，且参数列表的类型或个数存在不同
●34可变参数
方法名(参数的类型名 ...参数名)
●37参数传递
Java里方法的参数传递方式只有一种： 值传递（参数值的副本）
形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参
形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参
●47包与MVC
控制器(Controller)层 ，数据模型(Model)层 ，视图模型(Viewer)层
解析用户请求并拆分逻辑，承载数据处理数据，与用户直接进行交互
●51权限修饰符
开发中，一般成员实例变量都习惯使用private修饰，再提供相应的public权限的get/set方法访问
对于final的实例变量，不提供set()方法
对于static final的成员变量，习惯上使用public修饰
●57构造方法
[权限修饰符] 构造器名(参数列表){}
不能有return语句返回值
●61JavaBean和 UML类图
————————————————————————
⚫第07章_面向对象编程（进阶）
●1. 关键字：this
◽指代本类成员变量（属性），如果在本类中未找到，会从父类中查找
◽this()：调用本类的无参构造器
◽this(实参列表)：调用本类的有参构造器
◽this方法只能声明在构造器首行
●2.2 继承的语法
[修饰符] class 类B extends 类A {
	...
}
◽子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的get/set方法进行访问
◽Java只支持单继承，不支持多重继承
●3.2 方法重写的要求
◽子类重写的方法`必须`和父类被重写的方法具有相同的`方法名称`、`参数列表`。
◽子类重写的方法的返回值类型`不能大于`父类被重写的方法的返回值类型。（例如：Student < Person）。如果返回值类型是基本数据类型和void，那么必须是相同
◽子类重写的方法使用的访问权限`不能小于`父类被重写的方法的访问权限。（public > protected > 缺省 > private）① 父类私有方法不能重写   ② 跨包的父类缺省的方法也不能重写
◽子类方法抛出的异常不能大于父类被重写方法的异常
◽子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。
●5. 关键字：super
◽指代父类成员变量（属性）和方法
◽非supe修饰方法，先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯
◽super修饰方法，从当前子类的直接父类找，如果没有，继续往上追溯
◽避免子类声明和父类重名的成员变量
◽super构造方法同this，另外如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，则子类此构造器默认调用"super()"，若找不到父类无参构造方法则会报错
●7.1 多态的形式和体现
◽父类的引用=子类的对象。子类的方法重写。编译时，看左边（父类）；运行时，看右边（父类虚方法，动态绑定子类）
◽开发中无法确定它具体的类型，只能确定它是某个系列的类型。变量引用的子类对象不同，执行的方法就不同，实现动态绑定
◽开发中使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。
◽对扩展开放，对修改关闭
◽通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能
●7.6 向上转型与向下转型
◽父类的引用=子类的对象。子类的方法未重写（父类没有），无法调用，必须先将父类的对象向下转型为子类。问题：一个父类的不同子类可能不匹配无法强制转换，ClassCastException异常
◽对象a instanceof 数据类型A 。只要用instanceof判断返回true的，那么强转为该类型就一定是安全的
●8. Object 类的使用
如果一个类没有特别指定父类，那么默认则继承自Object类，其中有6个重要的方法
◽equals()与==
一般情况，比较引用的是否是同一个对象
特殊情况，重写过equals()的类File、String、Date及包装类（Wrapper Class）比较类型及内容，而不比较引用的是否是同一个对象
用“==”进行比较时，符号两边的`数据类型必须兼容`(可自动转换的基本数据类型除外)，否则编译出错
◽toString()
自动调用：与String连接+，输出print
◽clone()
克隆
◽finalize()
回收
◽getClass()
获取对象的运行时类型
◽hashCode()
返回对象hash值
●8.3 native关键字的理解
使用native关键字说明这个方法是原生函数，也就是这个方法是用`C/C++`等非Java语言实现的，并且`被编译成了DLL`，由Java去调用。
————————————————————————
⚫第08章_面向对象编程（高级）
●1. 关键字：static
◽在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。
◽静态方法可以被子类继承，但不能被子类重写。
◽因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。
●2. 单例(Singleton)设计模式
经典的设计模式共有23种（创建型5+结构型7+行为型11），单例模式属于创建型5的一种，应用场景：任务管理器，回收站，应用程序的日志应用，数据库连接池
在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。有2种主要实现方式
◽饿汉式：立即加载，多线程安全
类被加载直到类被卸载时，静态变量会一直占用内存
◽懒汉式：延迟加载
节约内存，线程不安全不能保证单例的唯一性，不适用于多线程场景
●4. 类的成员之四：代码块
对Java类或对象进行初始化，先于构造器执行，分为静态代码块（随着类的加载而加载，且只执行一次）和非静态代码块（每次创建对象的时候，都会执行一次）
static{
        静态代码块
    }
●5. final关键字
表示最终形态，类不能被继承，方法不能被重写，变量成为常量
●6. 抽象类与抽象方法(或abstract关键字)
抽象类，抽象方法用abstract修饰（在其他修饰符后）Java语法规定，包含抽象方法的类必须是抽象类
功能：抽象父类方法只有抽象方法签名，没有方法体，交给子类实现。
代码：[其他修饰符] abstract 返回值类型 方法名([形参列表]);
特点
◽抽象类不能创建对象
◽抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的
◽抽象类中，不一定包含抽象方法，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计
◽抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类
●7.3 接口定义格式
接口与类定义方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型
接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化
[修饰符] interface 接口名{
 	//接口的成员列表：
    // 公共的静态常量
    // 公共的抽象方法
    
    // 公共的默认方法（JDK1.8以上）
    // 公共的静态方法（JDK1.8以上）
    // 私有方法（JDK1.9以上）
}
●7.4 接口的使用规则
◽类实现接口与类继承父类方式相似，但是使用 implements 关键字，接口中的静态方法不能被继承也不能被重写
[修饰符] class 实现类 extends 父类 implements 接口{
    // 重写接口中抽象方法【必须】，除非实现类是抽象类
  	// 重写接口中默认方法【可选】
}
◽接口的多实现，与一个类只能继承一个父类不同，产物是类
[修饰符] class 实现类 extends 父类 implements 接口1,接口2{
	// 重写接口中抽象方法【必须】，抽象方法重名只需要重写一次
}
◽接口的多继承，与类的多继承相同，使用 extends 关键字，产物是接口
[修饰符] interface 接口名 extends 父接口1,父接口2{
	// 新的抽象方法
}
◽接口，静态成员，静态方法
通过接口名直接调用接口的静态方法和静态常量
●7.5 JDK8中相关冲突问题
◽类优先原则
当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。
◽接口冲突，保留唯一
当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，通过“`接口名.super.方法名`"的方法选择保留哪个接口的默认方法
◽常量冲突，加上类接口名前缀访问
当子类继承父类又实现父接口，或同时实现多个接口，而存在相同同名常量，通过super.x，接口名.x区分访问
●7.7 接口与抽象类之间的对比
接口是一种规范要求更严格。抽象类更像是模板，允许构造方法，普通方法，变量
开发中接口更好用，不受单继承限制
●8.2 成员内部类
[修饰符] class 外部类{
    [其他修饰符] [static] class 内部类{
    }
}
◽外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式
◽成员内部类可以直接使用外部类的所有成员，包括私有的数据
◽当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的
●8.3 局部内部类
[修饰符] class 外部类{
    [修饰符] 返回值类型  方法名(形参列表){
            [final/abstract] class 内部类{
        }
    }    
}
因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题
●9.3.2 enum方式定义的要求和特点
◽枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。
◽列出的实例系统会自动添加 public static final 修饰。
◽如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。
●9.4 enum中常用方法
String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！
static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法
static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
String name():得到当前枚举常量的名称。建议优先使用toString()。
int ordinal():返回当前枚举常量的次序号，默认从0开始
●9.5 实现接口的枚举类
和普通 Java 类一样，枚举类可以实现一个或多个接口
●10.3 三个最基本的注解（annotation）
在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在`JavaEE/Android中注解占据了更重要的角色`，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的`繁冗代码`和`XML配置`等
@Override用于检测被标记的方法为有效的重写方法
@Deprecated用于表示被标记的数据已经过时，不推荐使用
@SuppressWarnings抑制编译警告
●10.4 元注解
自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中
●10.6 JUnit单元测试
●11.4 包装类与基本数据类型间的转换
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
●11.5 基本数据类型、包装类与字符串间的转换


————————————————————————
⚫第09章_异常处理
●1.3 异常的抛出机制
Java中把不同的异常用不同的类表示，一旦发生某种异常，就`创建该异常类型的对象`，并且抛出（throw）。然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止
●2. Java异常体系
java.lang.Throwable类是Java程序执行过程中发生的异常事件对应的类的根父类。
Throwable可分为两类：Error和Exception。分别对应着`java.lang.Error`与`java.lang.Exception`两个类。
Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。
Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序也会挂掉
● 4.2 方式1：捕获异常（try-catch-finally）
Java提供了异常处理的抓抛模型
◽Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为`抛出(throw)异常`。
◽如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为`捕获(catch)异常`。
◽如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。
异常处理的执行过程
◽如果在程序运行时，try块中的代码发生了异常，根据异常对象的类型，将从上到下选择第一个匹配的catch分支执行。此时try中发生异常的语句下面的代码将不执行，而整个try...catch之后的代码可以继续运行。
◽catch如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。
◽catch如果有多个catch分支，并且多个异常类型有父子类关系，必须保证小的子异常类型在上，大的父异常类型在下。否则，报错。
◽finally必然执行，可以省略。内容常常包括数据库连接、输入流输出流、Socket连接、Lock锁的关闭
异常处理的应用
◽运行时异常RuntimeException类或是它的子类，即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过 ( 但运行时会发生异常使得程序运行终止 )所以，对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。
◽非运行时异常IOException等类型必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。
●4.3 方式2：声明抛出异常类型（throws）
在方法头应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。（在当前方法体中可能不适合处理或无法给出合理的处理方式）
修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }  
方法重写
◽返回值类型
    ◽基本数据类型和void：必须相同
    ◽引用数据类型：<=
◽权限修饰符：>=，而且要求父类被重写方法在子类中是可见的
◽编译时异常throws：<=（抛出异常子类或不抛，实在要处理用方式1：捕获异常）
●4.4 两种异常处理方式的选择
◽如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。
◽如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally进行处理，不能throws。
◽开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。
●5. 手动抛出异常对象：throw
throw new 异常类名(参数);
●6. 自定义异常
◽自定义一个编译时异常类型：自定义类继承`java.lang.Exception`。
​◽自定义一个运行时异常类型：自定义类继承`java.lang.RuntimeException`。
◽自定义的异常只能通过throw抛出。
————————————————————————
⚫第10章_多线程
●1.3 线程调度
◽分时调度
所有线程`轮流使用` CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。
◽抢占式调度
让`优先级高`的线程以`较大的概率`优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。
●1.5.2 并行与并发
◽并行（parallel）
指两个或多个事件在`同一时刻`发生（同时发生）。指在同一时刻，有`多条指令`在`多个CPU`上`同时`执行
◽并发（concurrency）
指两个或多个事件在`同一个时间段内`发生。即在一段时间内，有`多条指令`在`单个CPU`上`快速轮换、交替`执行，使得在宏观上具有多个进程同时执行的效果
●2.2 方式1：继承Thread类
◽定义Thread类的子类，并重写该类的run()，只是普通方法，没有启动多线程模式
◽调用start()方法启动线程，run()方法由JVM调用，执行的过程控制都有操作系统的CPU调度决定
◽一个线程对象只能调用一次start()
●2.3 方式2：实现Runnable接口
◽定义Runnable接口的实现类，并重写该类的run()
◽创建Runnable实现类的实例，并以此实例作为Thread的target参数来创建Thread对象（可创建多个不同的对象），调用线程对象的start()
●2.5 对比两种方式
◽避免了单继承的局限性
◽多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。
◽增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
●3. Thread类的常用结构
public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。
public void setName(String name)：设置该线程名称。
public static Thread currentThread() :返回对当前正在执行的线程对象的引用。在Thread子类中就是this，通常用于主线程和Runnable实现类
public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
public static void yield()：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会
void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。
public final int getPriority() ：返回线程优先级，中高低
public final void setPriority(int newPriority) ：改变线程的优先级，范围在[1,10]之间。
setDaemon(true)将指定线程设置为守护线程（兜底线程），必须在线程启动之前设置
●4. 多线程的生命周期
NEW,
RUNNABLE,
BLOCKED,锁阻塞。一个正在阻塞、等待一个监视器锁（锁对象）的线程处于这一状态。只有获得锁对象的线程才能有执行机会
WAITING,无限等待。未设置了时间的Thread类的`sleep`或`join`，Object类的`wait`，LockSupport类的`park`方法
TIMED_WAITING,计时等待。设置了时间参数
TERMINATED;
●5.2.2 同步代码块和同步方法2选1
◽同步方法：直接加synchronized，默认指定监视器2种
静态方法：当前类的Class对象（类名.class）；非静态方法：this
◽同步代码块：圈起来加synchronized(同步锁)，手动指定监视器（同上2种）
◽指定监视器必须唯一，this在方式1：继承Thread类可能不唯一。因此同步方法非静态方法（this）不适配继承Thread类，同步代码块手动避开指定this
继承Thread类中，方法访问非静态因此必须是非静态方法，怎么指定监视器必须唯一？方法内改成代码块手动指定监视器
●6.1 单例设计模式的线程安全问题
懒汉式添加同步锁，防止多线程调用getInstance方法再创建对象2
●6.2 死锁
◽诱发死锁的原因：4个条件，同时出现就会触发死锁。
互斥条件
占用且等待
不可抢夺（或不可抢占）
循环等待
◽避免死锁的方法
针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。
针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。
针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。
针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。
●6.3Lock(锁)
◽Lock锁对象对同一段线程代码也要保持一致，多线程一把锁
private static final ReentrantLock lock = new ReentrantLock();
◽如果同步代码有异常，要将unlock()写入finally语句块，保证锁的关闭
◽Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁
◽Lock只有代码块锁，synchronized有代码块锁和方法锁
◽使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。
◽Lock锁可以对读不加锁，对写加锁，synchronized不可以
◽Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以

●7.2 等待唤醒机制
◽wait：线程不再活动，不再参与调度，进入 `wait set` 中。等待“`通知（notify）`”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（`ready queue`）从原进度继续运行
◽notify：选取所通知对象的 wait set 中的一个线程释放
◽notifyAll：释放所通知对象的 wait set 上的全部线程
如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；
否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态

●7.4 调用wait和notify需注意的细节
wait方法与notify方法必须要在`同步代码块`或者是`同步函数`中使用。因为：必须要`通过锁对象`调用这2个方法。wait方法与notify方法必须要由`同一个锁对象调用`

●7.7 是否释放锁的操作
◽释放锁的操作：当前线程在同步代码块、同步方法中：
执行结束
遇到break、return终止了该代码块、该方法的继续执行。
出现了未处理的Error或Exception，导致当前线程异常结束。
执行了锁对象的wait()方法，当前线程被挂起，并释放锁。
◽不会释放锁的操作
线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。
线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该该线程挂起，该线程不会释放锁（同步监视器）。应尽量避免使用suspend()和resume()这样的过时来控制线程。

●8.1 新增方式一：实现Callable接口
与使用Runnable相比， Callable功能更强大些
◽相比run()方法，可以有返回值
◽方法可以抛出异常
◽支持泛型的返回值（需要借助FutureTask类，获取返回结果）
◽FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值
◽缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低

●8.2 新增方式二：使用线程池
提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用，便于线程管理，corePoolSize：核心池的大小，maximumPoolSize：最大线程数，keepAliveTime：线程没有任务时最多保持多长时间后会终止
◽ `ExecutorService`：真正的线程池接口。
◽ `Executors`：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。

————————————————————————

⚫第11章_常用类和基础API
●1.2 String的内存结构
常量池：不会存在相同内容的常量。常量+常量“”，或拼接后调用intern方法从常量池获取
堆：存在变量String对象的运算，常量+变量
●2.1 StringBuffer与StringBuilder的理解
◽String:不可变的字符序列； 底层使用char[]数组存储(JDK8.0中)
◽StringBuffer:可变的字符序列；线程安全（方法有synchronized修饰），效率低；底层使用char[]数组存储 (JDK8.0中)
◽StringBuilder:可变的字符序列； jdk1.5引入，线程不安全的，效率高；底层使用char[]数组存储(JDK8.0中)

●4. JDK8：新的日期时间API
◽本地日期时间：LocalDate、LocalTime、LocalDateTime
◽瞬时：Instant
◽日期时间格式化：DateTimeFormatter
◽指定时区日期时间：ZondId和ZonedDateTime
◽持续日期/时间：Period和Duration
●5.1 自然排序：java.lang.Comparable
实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。
●5.2 定制排序：java.util.Comparator
可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制
●6. 系统相关类
◽java.lang.System类
◽java.lang.Runtime类
●7. 和数学相关的类
◽java.lang.Math
◽java.math包BigInteger和BigDecimal
◽java.util.Random
————————————————————————

⚫第12章_集合框架
●1.3 Java集合框架体系
◽Collection接口：用于存储一个一个的数据，也称`单列数据集合`。
List子接口：用来存储有序的、可以重复的数据（主要用来替换数组，"动态"数组）实现类：ArrayList(主要实现类)、LinkedList、Vector
Set子接口：用来存储无序的、不可重复的数据（类似于高中讲的"集合"）实现类：HashSet(主要实现类)、LinkedHashSet、TreeSet
◽Map接口：用于存储具有映射关系“key-value对”的集合，即一对一对的数据，也称`双列数据集合`。实现类：HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties

●3. Iterator(迭代器)接口
public E next():返回迭代的下一个元素。
public boolean hasNext():如果仍有元素可以迭代，则返回 true。

●3.3 foreach循环
for(元素的数据类型 局部变量 : Collection集合或数组){
}

●4. Collection子接口1：List
◽ArrayList变长数组，在各种List中，最好把`ArrayList作为默认选择`
◽LinkedList链表数组，插入、删除频繁时使用
◽Vector，比ArrayList慢，但线程安全

●5. Collection子接口2：Set
◽HashSet，对于存放在Set容器中的对象，对应的类一定要重写hashCode()和equals(Object obj)方法
◽LinkedHashSet，使用`双向链表`维护元素的次序，这使得元素看起来是以`添加顺序`保存的。插入性能略低但可以迭代访问
◽TreeSet红黑树，判断`两个对象是否相等的唯一标准`是：两个对象通过 `compareTo(Object obj) 自然排序或compare(Object o1,Object o2)`定制排序方法比较返回值

●6.2 Map中key-value特点
Map 中的 `key用Set来存放`，`不允许重复`，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法
不同key对应的`value可以重复`。value所在的类要重写equals()方法。

●6.3 Map的主要实现类：HashMap
◽允许使用 null 作为 key 或 value
◽存储数据采用的哈希表结构，底层使用`一维数组`+`单向链表`+`红黑树`进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。
◽HashMap `判断两个key相等的标准`是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。
◽HashMap `判断两个value相等的标准`是：两个 value 通过 equals() 方法返回 true。

●6.4 Map实现类之二：LinkedHashMap
使用`双向链表`维护元素的次序，这使得元素看起来是以`添加顺序`保存的。插入性能略低但可以迭代访问

●6.5 Map实现类之三：TreeMap
TreeMap红黑树，判断`两个 Key是否相等的唯一标准`是：两个对象通过 `compareTo(Object obj) 自然排序或compare(Object o1,Object o2)`定制排序方法比较返回值

●6.6 Map实现类之四：Hashtable
比HashMap慢，但线程安全（不允许使用 null 作为 key 或 value）

●6.7 Map实现类之五：Properties
◽Properties 类是 Hashtable 的子类，该对象用于处理属性文件
◽由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型
◽存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法

●7. Collections工具类
Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法，均为static方法
————————————————————————
⚫第13章_泛型

●3.2 自定义泛型类或泛型接口
◽泛型的指定中必须使用引用数据类型。不能使用基本数据类型，此时只能使用包装类替换。
◽除创建泛型类对象外，子类继承泛型类时、实现类实现泛型接口时，可以：确定泛型结构中的泛型参数，继续使用泛型参数，新增泛型参数
●3.3 自定义泛型方法
◽方法，也可以被泛型化，与其所在的类是否是泛型类没有关系
●5. 通配符的使用
 `List<?>`是`List<String>`、`List<Object>`等各种泛型List的父类。

————————————————————————
⚫第14章_数据结构与集合源码
●6.4 经典二叉树
◽二叉排序/查找/搜索树：即为BST  (binary search/sort tree)。满足如下性质：
（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值； 
（2）若它的右子树上所有结点的值均大于它的根节点的值； 
（3）它的左、右子树也分别为二叉排序/查找/搜索树。
对二叉查找树进行中序遍历，得到有序集合。便于检索。
◽平衡二叉树：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：
（1）它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
（2）并且左右两个子树也都是一棵平衡二叉树
（3）不要求非叶节点都有两个子结点 
平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。
◽红黑树
（1）根节点是黑色，每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点）
（2）每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 
（3）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍）
————————————————————————
⚫第15章_File类与IO流
●1. java.io.File类的使用
public File(String pathname)

●2.2 流的分类
节点流：直接从数据源或目的地读写数据
处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能

●2.3 流的API
输入字节流InputStream
输入字符流Reader
输出字节流OutputStream
输出字符流Writer

●3.1 Reader与Writer
当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。

●3.2 FileReader 与 FileWriter
因为出现流资源的调用，为了避免内存泄漏，需要使用try-catch-finally处理异常
对于输入流来说，File类的对象必须在物理磁盘上存在
对于输出流来说，File类的对象是可以不存在的，自动创建

●3.3  关于flush（刷新）
因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的
flush() ：刷新缓冲区，流对象可以继续使用

●5. 处理流之一：缓冲流
BufferedReader：`public String readLine()`: 读一行文字。 
BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。
在开发中，只需要关闭最外层的流即可，因为在关闭外层流时，内层的流也会被关闭

●6. 处理流之二：转换流
◽InputStreamReader*
转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集
◽OutputStreamWriter
转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集

●7. 处理流之三/四：数据流、对象流
数据流：DataOutputStream、DataInputStream
◽DataOutputStream：允许应用程序将基本数据类型、String类型的变量写入输出流中
◽DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String类型的变量。

对象流：ObjectOutputStream、ObjectInputStream
◽ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现Java各种基本数据类型的数据以及对象的持久存储。
◽ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。

●7.3 认识对象序列化机制
序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中`持久保存`了一个对象的信息。 

●7.4 如何实现序列化机制
如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现`java.io.Serializable ` 接口

●8.1 标准输入、输出流
System.in和System.out分别代表了系统标准的输入和输出设备
默认输入设备是：键盘，输出设备是：显示器

●9. apache-common包的使用
Apahce软件基金会属于第三方，（Oracle公司第一方，我们自己第二方，其他都是第三方）我们要使用第三方开发好的工具，需要添加jar包
————————————————————————
⚫第16章_网络编程
●2.2 通信要素一：IP地址和域名
◽本地回环地址(hostAddress)：`127.0.0.1`  
◽主机名(hostName)：`localhost`

●2.3 通信要素二：端口号
用两个字节表示的整数，它的取值范围是0~65535**。
◽公认端口：0~1023。被预先定义的服务通信占用，如：HTTP（80），FTP（21），Telnet（23）
◽注册端口：1024~49151。分配给用户进程或应用程序。如：Tomcat（8080），MySQL（3306），Oracle（1521）。
◽动态/ 私有端口：49152~65535。

●3. 网络编程API
◽InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address
◽网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字（Socket）。Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输
◽ServerSocket：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入。
◽Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。
◽DatagramSocket：此类表示用来发送和接收UDP数据报包的套接字。 

●4. TCP网络编程
◽客户端程序包含以下四个基本的步骤 ：
* 创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。
* 打开连接到 Socket  的输入/ 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输
* 按照一定的协议对 Socket 进行读/ 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。
* 关闭 Socket ：断开客户端到服务器的连接，释放线路
◽服务器端程序包含以下四个基本的 步骤：
* 调用 ServerSocket(int port)  ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。
* 调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。
* 调用  该Socket 类对象的 getOutputStream()  和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。
* 关闭Socket 对象：客户端访问结束，关闭通信套接字。

●5. UDP网络编程
◽发送端程序包含以下四个基本的步骤：
* 创建DatagramSocket ：默认使用系统随机分配端口号。
* 创建DatagramPacket：将要发送的数据用字节数组表示，并指定要发送的数据长度，接收方的IP地址和端口号。
* 调用  该DatagramSocket 类对象的 send方法 ：发送数据报DatagramPacket对象。
* 关闭DatagramSocket 对象：发送端程序结束，关闭通信套接字。
◽接收端程序包含以下四个基本的步骤 ：
* 创建DatagramSocket ：指定监听的端口号。
* 创建DatagramPacket：指定接收数据用的字节数组，起到临时数据缓冲区的效果，并指定最大可以接收的数据长度。
* 调用  该DatagramSocket 类对象的receive方法 ：接收数据报DatagramPacket对象。。
* 关闭DatagramSocket ：接收端程序结束，关闭通信套接字。

●6. URL编程
URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获
————————————————————————
⚫第17章_反射机制
●1.2 反射概述
Reflection（反射）是被视为`动态语言`的关键，反射机制允许程序在`运行期间`借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法

●3.3.1 类加载器的作用
将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。
类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。

●4.1 应用1：创建运行时类的对象
◽方式1：直接调用Class对象的newInstance()方法**
1）获取该类型的Class对象  
2）调用Class对象的newInstance()方法创建对象
◽方式2：通过获取构造器对象来进行实例化**
1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器
2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。
3）通过Constructor实例化对象。

●4.2 应用2：获取运行时类的完整结构
可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）。

●4.3 应用3：调用运行时类的指定结构
◽调用指定的属性：在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作
◽调用指定的方法

●5. 应用4：读取注解信息
自定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME
————————————————————————
⚫第18章_JDK8-17新特性

●2.4 Lambda 及其使用举例
Lambda匿名函数作对象，形参列表和方法体构成，能省则省
Runnable r=() -> {
    
}

●3.1 什么是函数式接口
只包含`一个抽象方法`（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法
我们可以在一个接口上使用 `@FunctionalInterface` 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口

●3.4.1 之前的函数式接口
◽java.lang.Runnable
public void run()
◽java.lang.Iterable<T>
public Iterator<T> iterate()
◽java.lang.Comparable<T>
public int compareTo(T t)
◽java.util.Comparator<T>
public int compare(T t1, T t2)

●4.1 方法引用
当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用
格式：使用方法引用操作符 “`::`” 将类(或对象) 与 方法名分隔开来
Consumer<String> c = sout::println
◽情况1：`对象 :: 实例方法名`
◽情况2：`类 :: 静态方法名`
◽情况3：`类 :: 实例方法名`(方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者)

●4.2 构造器引用
当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用
Consumer<String> c = String::new

●4.3 数组构造引用
当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。

●5. Java8新特性：强大的Stream API
使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询
实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理

●5.4 Stream的操作三个步骤
◽创建 Stream
一个数据源（如：集合、数组），获取一个流
◽中间操作
每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个`操作链`，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行
◽终止操作
终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream

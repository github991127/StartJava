⚫●◽★
——————————————————————
⚫基础篇
●1.2.6 数据模型
关系型数据库（RDBMS）：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。

●2.1 SQL通用语法
1). SQL语句可以单行或多行书写，以分号结尾。
2). SQL语句可以使用空格/缩进来增强语句的可读性。
3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。
4). 注释：
单行注释：-- 注释内容 或 # 注释内容
多行注释：/* 注释内容 */

●2.2 SQL分类
◽DDL数据定义语言，用来定义数据库对象(数据库，表，字段)
◽DML数据操作语言，用来对数据库表中的数据进行增删改
◽DQL数据查询语言，用来查询数据库中表的记录
◽DCL数据控制语言，用来创建数据库用户、控制数据库的访问权限

●2.3 DDL
数据类型：数值类型、字符串类型、日期时间类型

●2.5 DML
添加数据：字符串和日期型数据应该包含在引号中。
修改数据：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。
删除数据： DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。

●2.6 DQL
基本查询（不带任何条件）
条件查询（WHERE）
聚合函数（count、max、min、avg、sum）
分组查询（group by）
排序查询（order by）
分页查询（limit）

●2.6.2 基础查询
◽查询多个字段
◽字段设置别名
◽去除重复记录

●2.6.3 条件查询
运算符

●2.6.4 聚合函数
列计算

●2.6.5 分组查询
分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义
where分组前过滤，having分组后过滤
where不能对聚合函数进行判断，having可以
执行顺序: where > 聚合函数 > having

●2.6.6 排序查询
ASC : 升序(默认值)
DESC: 降序

●2.6.7 分页查询
起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。
分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。
如果查询的是第一页数据，起始索引可以省略。

●2.6.9 执行顺序
from ... where ... group by ...
having ... select ... order by ... limit ...

●2.7 DCL
◽在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。
◽主机名可以使用 % 通配。
◽这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库管理员）使用。
◽授权时， 数据库名和表名可以使用 * 进行通配，代表所有。

●3. 函数
MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。


●4. 约束
作用于表中字段上，用于限制存储在表中的数据，可以在创建表/修改表的时候添加约束。
添加了外键约束之后，不能非法删除或更新父表记录，而是根据删除/更新行为的约束合法地自动变化
◽非空约束 限制该字段的数据不能为null NOT NULL
◽唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE
◽主键约束 主键是一行数据的唯一标识，要求非空且唯一PRIMARYKEY
◽默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT
◽检查约束 (8.0.16版本之后)保证字段值满足某一个条件 CHECK
◽外键约束 用来让两张表的数据之间建立连接，保证数据的一致性和完整性FOREIGNKEY

●5.2 多表查询
◽内连接：相当于查询A、B交集部分数据
查询员工 及其 所属领导的名字
◽左外连接：查询左表所有数据，以及两张表交集部分数据
◽右外连接：查询右表所有数据，以及两张表交集部分数据。只是先后顺序不同，通用使用左外连接
查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来
◽自连接：当前表与自身的连接查询，自连接必须使用表别名
上述情况，员工领导在同一张表时，自连接

●5.5.2 联合查询
union all将全部的数据直接合并在一起
union合并之后，并且数据去重
字段数量不一致，合并报错

●5.6 子查询
INSERT / UPDATE / DELETE / SELECT 内嵌套查询

●6. 事务
是一组操作的集合，它是一个不可分割的工作单位。同时成功或失败，如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态
默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。
语句放在一段操作的开头和结尾，中途出错会回滚事务

●6.3 事务四大特性
◽原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
◽一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
◽隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
◽持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。
上述就是事务的四大特性，简称ACID。

●6.5 事务隔离级别
隔离级别 有4级，依次禁止脏读，不可重复读，幻读。事务隔离级别越高，数据越安全，但是性能越低。
◽赃读：一个事务读到另外一个事务还没有提交的数据
◽不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
◽幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 "幻影"。
——————————————————————
⚫进阶篇
●1.2 存储引擎介绍
◽MySQL体系结构：连接层，服务层，引擎层，存储层
◽存储引擎基于表，是存储数据、建立索引、更新/查询数据等技术的实现方式 
◽创建表时，没有指定存储引擎，数据库会自动选择默认的存储引擎

●1.3 存储引擎特点
◽InnoDB：DML操作遵循ACID模型，支持事务；行级锁，提高并发访问性能；支持外键FOREIGN KEY约束，保证数据的完整性和正确性；
innoDB引擎的每张表都会对应这样一个.ibd表空间文件，存储该表的表结构（sdi）、数据和索引。
逻辑存储结构：表空间，段，区（1M），页（16K磁盘管理的最小单元），行
◽MyISAM：不支持事务，不支持外键；支持表锁，不支持行锁；访问速度快
◽Memory：表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。hash索引（默认）

●1.4 存储引擎选择
InnoDB: 应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作
MyISAM ： 以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高
MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。太大的表无法缓存在内存中

●2.2 索引结构
◽B+Tree索引（默认）：最常见的索引类型，大部分引擎都支持 B+ 树索引
◽Hash索引：底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询
◽R-tree(空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
◽Full-text(全文索引)：是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES

●2.2.4 B+Tree
◽二叉树，度为2，key为1的树
◽B-Tree，度为n，key为n-1的树，一种多叉路衡查找树
n个指针从一个节点各个key中间指出。插入数据后若超过n，最中间的数上移，其余数分裂成左右两个树，上层若超过n则迭代此过程
◽B+Tree，度为n，key为n-1的树，一种多叉路衡查找树
叶子节点才存数据，上面只存指针。插入数据后若超过n，最中间的数复制上移，其余数分裂成左右两个树并添加左向右的指针形成单向链表
◽MySQL优化B+Tree
链表变为双向循环链表，提高区间访问的性能，利于排序

●2.2.5 Hash
◽Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
◽无法利用索引完成排序操作
◽查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了

●2.3 索引分类
◽在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引（默认建立）、唯一索引、常规索引、全文索引。
◽在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：聚集索引(Clustered Index)，二级索引(Secondary Index)
聚集索引的叶子节点下挂的是这一行的数据 。
二级索引的叶子节点下挂的是该字段值对应的主键值。
回表查询： 先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值
◽聚集索引选取优先规则:
主键，第一个唯一（UNIQUE）索引，自动生成一个rowid作为隐藏的聚集索引

●2.5 SQL性能分析
◽SQL执行频率
查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。
◽慢查询日志
默认关闭，只会记录执行时间超多预设时间的SQL
◽profile详情
默认关闭，记录每条执行时间
◽explain
获取 MySQL 如何执行 SELECT 语句的信息

●2.6 索引使用
◽最左前缀法则
联合索引中，查询从索引的最左列开始（查询语句的字段存在即可，和先后无关），并且不跳过索引中的列。如果跳跃某一列，后面的字段索引失效
◽范围查询
联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。>= 或 <= 走联合索引，应优先使用

●2.6.4 索引失效情况
◽索引列运算：不要在索引列上进行运算操作， 索引将失效
◽字符串不加引号：字符串类型字段使用时，不加引号，索引将失效
◽模糊查询：头部模糊匹配，索引失效
◽or连接条件：左右两侧字段都有索引时，索引才会生效
◽数据分布影响：如果MySQL评估使用索引比全表更慢，则不使用索引。得具体情况具体分析，并不是固定的

●2.6.5 SQL提示
建议，忽略，强制

●2.6.6 覆盖索引
查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到（id和当前查询条件的字段），不需要回表查询
优化建议：针对经常查询的非主键字段组建立联合索引

●2.6.7 前缀索引
选择性：不重复的索引值（基数）和数据表的记录总数的比值，唯一索引的选择性是1
根据选择性，只将字符串的一部分前缀建立索引，大大节约索引空间，从而提高索引效率

●2.7 索引设计原则
1). 针对于数据量较大，且查询比较频繁的表建立索引。
2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

●3. SQL优化-3.1 插入数据
批量插入数据（或load大批量本地数据），手动控制事务，主键要顺序插入

●3.2 主键优化
在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表
如果插入的数据行row在该页（默认16K）存储不下，将会存储到下一个页中，页与页之间会通过指针连接。每个页包含了2-N行数据（1链表指针无意义）
◽页分裂：乱序插入时，从顺序的下一个重新开辟页，移走一半进来，并更换指针（不推荐乱序插入）
◽页合并：删除时，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用，一页不足一半时，自动寻找可优化的前后合并
设计原则：
◽满足业务需求的情况下，尽量降低主键的长度。
◽插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
◽尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
◽业务操作时，避免对主键的修改。

●3.3 order by优化
排序操作，尽量要优化为 Using index（有序索引顺序扫描）而非而Using filesort（全表扫描存入缓冲区）
Using index必须要求最左前缀法则，Using index联合索引必须要求索引的升序降序
设计原则：
◽根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
◽尽量使用覆盖索引。
◽多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。
◽如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。

●3.4 group by优化
分组操作，尽量要优化为 Using index（有序索引顺序扫描）而非而Using temporary
Using temporary必须要求最左前缀法则，如abc联合索引，ab分组走索引，bc分组不走索引

●3.5 limit优化
设计原则：覆盖索引加子查询（只查id避免回表，然后根据id查想要的字段）

●3.6 count优化
◽不带条件count：MyISAM 引擎自带磁盘计数，InnoDB 引擎靠其他数据库，如redis
◽带条件count：count(字段) < count(主键 id) < count(1) ≈ count(*)，使用后两者
count(数字)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。
count(*)：InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。

●3.7 update优化
更新操作，缺少索引或索引失效，行锁升级为了表锁，并发性能大大降低。因此要根据索引更新

●4.1 视图
◽视图只保存了查询的SQL逻辑
◽当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改（插入，更新，删除）的每个行
◽MySQL允许基于另一个视图创建视图
CASCADED（默认）：检查新视图和原视图
LOCAL：只检查新视图
◽可更新：视图中的行与基础表中的行之间必须存在一对一的关系，且不包含
A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）
B. DISTINCT
C. GROUP BY
D. HAVING
E. UNION 或者 UNION ALL
◽优点：1). 简单2). 安全3). 数据独立

●4.2 存储过程
存储过程是数据库 SQL 语言层面的代码封装与重用，语句有if，case，while，repeat（相当于dowhile）， loop（LEAVE跳出，ITERATE继续）
◽系统变量：全局变量(GLOBAL): 全局变量针对于所有的会话。默认为会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。
◽用户定义变量：@变量名，无需对其进行声明或初始化，默认null
◽局部变量：DECLARE声明。范围在其内声明的BEGIN ... END块

●4.2.5 参数
参数的类型，主要分为以下三种：IN、OUT、INOUT

●4.2.10 游标
存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理

●4.2.11 条件处理程序
用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤
handler_action 的取值：跳出或继续
condition_value 的取值：状态码或状态码类别

●4.3 存储函数
存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的

●4.4 触发器
在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合，使用别名OLD和NEW来引用触发器中发生变化的记录内容。只支持行级触发

●5.2 全局锁
◽全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。
◽其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。
◽限制过大，谨慎使用。在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。

●5.3 表级锁
◽表锁：读锁阻塞读。写锁全阻塞
◽元数据锁：系统自动控制。为了避免DML与DDL冲突，保证读写的正确性。
当对一张表进行增删改查的时候，加MDL读锁(共享)。
当对表结构进行变更操作的时候，加MDL写锁(排他)。
◽意向锁：可以减少表锁的检查。事务提交，自动释放
问题：为避免行锁与表锁的冲突，用表锁前应检查每行数据是否加锁，意向锁避免此问题
意向共享锁，锁意向排他：与表锁的兼容范围不同

●5.4 行级锁
行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

●5.4.2 行锁
共享锁（S）：兼容共享锁，排斥排他锁，排他锁（X）：全部排斥，更严格
针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁升级为表锁。

●5.4.3 间隙锁&临键锁
间隙锁（小于）临键锁（小于等于），间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。
◽唯一索引：不存在记录加锁为间隙锁。会访问到不满足条件的第一个值为临键锁。
◽非唯一普通索引：间隙锁。

●6. InnoDB引擎
逻辑存储结构：表段区页行
内存结构：Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer
◽Buffer Pool：在执行增删改查操作时，先操作缓冲池中的数据，然后再以一定频率刷新到磁盘，底层采用链表数据结构管理Page
◽Change Buffer：针对于非唯一二级索引页，在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区。数据被读取时，再将数据合并恢复到Buffer Pool中
◽Adaptive Hash Index：InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则自动建立hash索引
◽Log Buffer：日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O

●6.2.3 磁盘结构
1). System Tablespace系统表空间是更改缓冲区的存储区域
2). File-Per-Table Tablespaces如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。
3). General Tablespaces通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。
4). Undo Tablespaces撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。
5). Temporary Tablespaces使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。
6). Doublewrite Buffer Files双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。
7). Redo Log重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo logbuffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。

●6.2.4 后台线程
1). Master Thread
核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。
2). IO Thread
在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IOThread主要负责这些IO请求的回调。
3). Purge Thread
主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。
4). Page Cleaner Thread
协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。

●6.3 事务原理
原子性、一致性、持久性由InnoDB中的redo log日志，undo log日志保证
隔离性是通过数据库的锁，MVCC保证

●6.4 MVCC
Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突。依赖于数据库记录中的三个隐式字段、undo log日志、readView。
1). 当前读
读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ...for update、update、insert、delete(排他锁)都是一种当前读。
2). 快照读
简单的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。
• Read Committed：每次select，都生成一个快照读。
• Repeatable Read：开启事务后第一个select语句才是快照读的地方。
• Serializable：快照读会退化为当前读。

●6.4.2 隐藏字段
DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。
DB_ROLL_PTR回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。
DB_ROW_ID 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。

●6.4.3 undolog
回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 
◽当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。
◽而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。
undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录

●6.4.4 readview
m_ids 当前活跃的事务ID集合（最小，最大+1），creator_trx_id ReadView创建者的事务ID
在进行匹配时，会从undo log的版本链，从上到下进行顺序匹配4个规则

READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。
REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。因此同一事务执行两次相同的select语句，查询到的结果是一样的

●7.2 常用工具
6个